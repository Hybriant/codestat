const chalk = require('chalk');
const { getLanguageColor } = require('./color-utils');

/**
 * Simple, clean display with minimal alignment calculations
 * @param {Object} results - Analysis results
 */
function displayResults(results) {
  // Clear, simple header
  console.log(chalk.cyan.bold('\n╭ CODE ANALYSIS ENGINE ╮\n'));
  console.log(chalk.yellow('╠═════════════════════════════════════════════════════╣\n'));
  
  // Centered project header
  console.log(chalk.magenta.bold('PROJECT ANALYSIS COMPLETE'));
  console.log(chalk.gray('────────────────────────────────────────────────────────'));
  console.log();
  
  // Summary section - simple aligned output
  displaySummary(results);
  
  // File types - simple table
  if (Object.keys(results.byFileType).length > 0) {
    displayFileTypes(results);
  }
  
  // Language distribution - simple bars
  if (Object.keys(results.byFileType).length > 0) {
    displayLanguageChart(results);
  }
  
  // Largest files
  if (results.largestFiles.length > 0) {
    displayLargestFiles(results);
  }
  
  // Metrics
  displayMetrics(results);
  
  // Footer
  console.log(chalk.yellow('╠═════════════════════════════════ ANALYSIS COMPLETE ════════════════════════════════╣'));
  console.log(chalk.green('[DONE] Project analysis completed successfully!'));
  console.log(chalk.gray('   Generated by CodeStat v1.0.2 - Advanced Code Analysis Tool\n'));
}

/**
 * Simple summary display
 */
function displaySummary(results) {
  console.log(chalk.cyan('[STA] SUMMARY STATISTICS'));
  console.log(chalk.gray('┌────────────────────────────────────────────────────────┐'));
  
  const stats = [
    { label: 'Total Files:', value: results.totalFiles || 0, color: 'green' },
    { label: 'Directories:', value: results.totalDirectories || 0, color: 'blue' },
    { label: 'Total Lines:', value: (results.totalLines || 0).toLocaleString(), color: 'yellow' },
    { label: 'Code Lines:', value: (results.codeLines || 0).toLocaleString(), color: 'cyan' },
    { label: 'Comments:', value: (results.commentLines || 0).toLocaleString(), color: 'magenta' },
    { label: 'Blank Lines:', value: (results.blankLines || 0).toLocaleString(), color: 'gray' }
  ];
  
  stats.forEach(stat => {
    const line = chalk.gray('│') + ' ' + 
                chalk[stat.color](stat.label.padEnd(15)) + ' ' + 
                chalk.white(stat.value.toString().padStart(10)) + 
                ' '.repeat(15) + chalk.gray('│');
    console.log(line);
  });
  
  console.log(chalk.gray('└────────────────────────────────────────────────────────┘\n'));
}

/**
 * Simple file type table
 */
function displayFileTypes(results) {
  console.log(chalk.magenta('[TYP] FILE TYPE ANALYSIS'));
  console.log(chalk.gray('┌─────────┬───────┬──────────┬──────┬──────────┬───────┐'));
  console.log(chalk.gray('│ Type    │ Files │   Lines  │ Code │ Comments │ Blank │'));
  console.log(chalk.gray('├─────────┼───────┼──────────┼──────┼──────────┼───────┤'));
  
  const sorted = Object.entries(results.byFileType)
    .sort((a, b) => b[1].files - a[1].files);
  
  sorted.forEach(([type, stats]) => {
    const colors = getLanguageColor(type);
    const line = chalk.gray('│') + ' ' +
                colors(type.toUpperCase().padEnd(7)) + ' ' +
                chalk.white(stats.files.toString().padStart(5)) + ' ' +
                chalk.white(stats.totalLines.toLocaleString().padStart(8)) + ' ' +
                chalk.white(stats.codeLines.toString().padStart(4)) + ' ' +
                chalk.white(stats.commentLines.toString().padStart(8)) + ' ' +
                chalk.white(stats.blankLines.toString().padStart(5)) + ' ' +
                chalk.gray('│');
    console.log(line);
  });
  
  console.log(chalk.gray('└─────────┴───────┴──────────┴──────┴──────────┴───────┘\n'));
}

/**
 * Simple language distribution chart
 */
function displayLanguageChart(results) {
  console.log(chalk.yellow('[CHT] LANGUAGE DISTRIBUTION'));
  console.log(chalk.gray('┌────────────────────────────────────────────────────────┐'));
  
  const sorted = Object.entries(results.byFileType)
    .sort((a, b) => b[1].totalLines - a[1].totalLines);
  
  sorted.forEach(([type, stats], index) => {
    const percentage = results.totalLines > 0 
      ? (stats.totalLines / results.totalLines * 100).toFixed(1) 
      : '0.0';
    
    const barLength = Math.floor(percentage / 2); // 2% per character
    const bar = '█'.repeat(barLength) + '░'.repeat(50 - barLength);
    
    const icon = index === 0 ? '*' : index === 1 ? '+' : 'x';
    const colors = getLanguageColor(type);
    
    const line = chalk.gray('│') + ' ' +
                icon + ' ' +
                colors(type.toUpperCase().padEnd(4)) + ' ' +
                chalk.yellow(percentage.padStart(5) + '%') + ' ' +
                chalk.gray(bar) + ' ' +
                chalk.gray('│');
    console.log(line);
  });
  
  console.log(chalk.gray('└────────────────────────────────────────────────────────┘\n'));
}

/**
 * Simple largest files display
 */
function displayLargestFiles(results) {
  console.log(chalk.red('[LEN] LARGEST FILES'));
  console.log(chalk.gray('┌──────┬──────────────────────────────┬───────┬──────┐'));
  console.log(chalk.gray('│ Rank │ File Name                   │ Lines │ Type │'));
  console.log(chalk.gray('├──────┼──────────────────────────────┼───────┼──────┤'));
  
  results.largestFiles.slice(0, 10).forEach((file, index) => {
    const rank = index === 0 ? '1st' : index === 1 ? '2nd' : index === 2 ? '3rd' : `${index + 1}th`;
    const colors = getLanguageColor(file.type);
    
    const line = chalk.gray('│') + ' ' +
                chalk.white(rank.padEnd(4)) + ' ' +
                chalk.cyan(file.path.padEnd(28).substring(0, 28)) + ' ' +
                chalk.yellow(file.lines.toString().padStart(5)) + ' ' +
                colors(file.type.toUpperCase().padEnd(4)) + ' ' +
                chalk.gray('│');
    console.log(line);
  });
  
  console.log(chalk.gray('└──────┴──────────────────────────────┴───────┴──────┘\n'));
}

/**
 * Simple metrics display
 */
function displayMetrics(results) {
  console.log(chalk.blue('[MET] CODE QUALITY METRICS'));
  console.log(chalk.gray('┌────────────────────────────────────────────────────────┐'));
  
  const commentRatio = results.totalLines > 0 
    ? (results.commentLines / results.totalLines * 100).toFixed(1) 
    : '0.0';
  const codeRatio = results.totalLines > 0 
    ? (results.codeLines / results.totalLines * 100).toFixed(1) 
    : '0.0';
  const avgLines = results.totalFiles > 0 
    ? Math.round(results.totalLines / results.totalFiles) 
    : 0;
  
  const metrics = [
    { 
      label: 'Comment Ratio:', 
      value: commentRatio + '%',
      status: commentRatio > 20 ? chalk.green('[GOOD]') : 
              commentRatio > 10 ? chalk.yellow('[FAIR]') : 
              chalk.red('[POOR]')
    },
    { 
      label: 'Code Ratio:', 
      value: codeRatio + '%',
      status: codeRatio > 70 ? chalk.green('[FAST]') : 
              codeRatio > 50 ? chalk.yellow('[NORM]') : 
              chalk.red('[SLOW]')
    },
    { 
      label: 'Avg Lines/File:', 
      value: avgLines.toString(),
      status: avgLines > 500 ? chalk.red('[HIGH]') : 
              avgLines > 200 ? chalk.yellow('[MED]') : 
              chalk.green('[LOW]')
    }
  ];
  
  metrics.forEach(metric => {
    const line = chalk.gray('│') + ' ' +
                chalk.blue(metric.label.padEnd(16)) + ' ' +
                chalk.white(metric.value.padStart(8)) + ' ' +
                metric.status +
                ' '.repeat(25) + chalk.gray('│');
    console.log(line);
  });
  
  console.log(chalk.gray('└────────────────────────────────────────────────────────┘\n'));
}

/**
 * Quick analysis display
 */
function displayQuickResults(results) {
  console.log(chalk.cyan.bold('\n╭ QUICK ANALYSIS ╮\n'));
  console.log(chalk.yellow('╠════════════════════════════════════════╣\n'));
  
  const stats = [
    { label: 'Files:', value: results.totalFiles, color: 'green' },
    { label: 'Total Lines:', value: results.totalLines.toLocaleString(), color: 'yellow' },
    { label: 'Code Lines:', value: results.codeLines.toLocaleString(), color: 'cyan' },
    { label: 'Avg Lines/File:', value: Math.round(results.totalLines / results.totalFiles), color: 'white' }
  ];
  
  stats.forEach(stat => {
    const line = chalk.gray('│') + ' ' +
                chalk[stat.color](stat.label.padEnd(15)) + ' ' +
                chalk.white(stat.value.toString().padStart(15)) +
                ' '.repeat(10) + chalk.gray('│');
    console.log(line);
  });
  
  console.log(chalk.yellow('╚════════════════════════════════════════╝\n'));
}

/**
 * File analysis display
 */
function displayFileResults(results) {
  console.log(chalk.cyan.bold('\n╭ FILE ANALYSIS ╮\n'));
  console.log(chalk.yellow('╠════════════════════════════════════════╣\n'));
  
  // File info
  const fileName = Object.keys(results.byFileType)[0] || 'Unknown';
  console.log(chalk.gray('│') + ' ' + chalk.cyan('Name:'.padEnd(10)) + ' ' + chalk.white(results.fileName.padEnd(35)) + ' ' + chalk.gray('│'));
  console.log(chalk.gray('│') + ' ' + chalk.white('Type:'.padEnd(10)) + ' ' + chalk.white(fileName.toUpperCase().padEnd(35)) + ' ' + chalk.gray('│'));
  console.log(chalk.gray('│') + ' ' + chalk.yellow('Size:'.padEnd(10)) + ' ' + chalk.white(formatFileSize(results.fileSize).padEnd(35)) + ' ' + chalk.gray('│'));
  console.log();
  
  // Line counts
  const lineStats = [
    { label: 'Total Lines:', value: results.totalLines, color: 'yellow' },
    { label: 'Code Lines:', value: results.codeLines, color: 'cyan' },
    { label: 'Comments:', value: results.commentLines, color: 'magenta' },
    { label: 'Blank Lines:', value: results.blankLines, color: 'gray' }
  ];
  
  lineStats.forEach(stat => {
    const line = chalk.gray('│') + ' ' +
                chalk[stat.color](stat.label.padEnd(13)) + ' ' +
                chalk.white(stat.value.toLocaleString().padStart(32)) +
                ' ' + chalk.gray('│');
    console.log(line);
  });
  
  console.log(chalk.yellow('╚════════════════════════════════════════╝\n'));
}

/**
 * Format file size
 */
function formatFileSize(bytes) {
  if (bytes === 0) return '0 B';
  
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

module.exports = {
  displayResults,
  displayQuickResults,
  displayFileResults
};