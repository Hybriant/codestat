const chalk = require('chalk');
const { getLanguageColor } = require('./color-utils');
const { 
  getTerminalWidth, 
  createResponsiveTable,
  truncateText,
  createProgressBar 
} = require('./terminal-utils');

/**
 * Displays analysis results with consistent column-based layout
 * @param {Object} results - Analysis results
 */
function displayResults(results) {
  const terminalWidth = getTerminalWidth();
  const isNarrow = terminalWidth < 80;
  
  // Main header
  const headerWidth = Math.min(56, terminalWidth - 4);
  console.log(chalk.cyan.bold('\n╭ CODE ANALYSIS ENGINE ╮\n'));
  console.log(chalk.yellow('╠═' + '═'.repeat(headerWidth) + '═╣\n'));
  
  // Project header - centered
  const projectText = 'PROJECT ANALYSIS COMPLETE';
  const projectPadding = Math.max(0, Math.floor((terminalWidth - projectText.length - 4) / 2));
  console.log(' '.repeat(projectPadding) + chalk.magenta.bold(projectText));
  console.log(chalk.gray('─'.repeat(Math.min(40, terminalWidth - 10))));
  console.log();

  // Summary Statistics - Using consistent table
  displaySummaryStats(results, terminalWidth);

  // File Type Breakdown
  if (Object.keys(results.byFileType).length > 0) {
    displayFileTypeAnalysis(results, terminalWidth, isNarrow);
  }

  // Language Distribution
  if (Object.keys(results.byFileType).length > 0) {
    displayLanguageDistribution(results, terminalWidth);
  }

  // Largest Files
  if (results.largestFiles.length > 0) {
    displayLargestFiles(results, terminalWidth);
  }

  // Code Quality Metrics
  displayCodeQualityMetrics(results, terminalWidth);
  
  // Final separator
  const sepWidth = Math.min(30, terminalWidth - 20);
  console.log(chalk.yellow('╠═' + '═'.repeat(sepWidth) + ' ANALYSIS COMPLETE ' + '═'.repeat(sepWidth) + '═╣'));
  console.log();
  
  // Footer
  const footerText = 'Project analysis completed successfully!';
  const footerPadding = Math.max(0, Math.floor((terminalWidth - footerText.length - 12) / 2));
  console.log(' '.repeat(footerPadding) + chalk.green('[DONE]') + chalk.white(' ' + footerText + ' ') + chalk.green('[DONE]'));
  console.log(chalk.gray('   Generated by CodeStat v1.0.2 - Advanced Code Analysis Tool'));
  console.log();
}

/**
 * Displays summary statistics in a consistent format
 */
function displaySummaryStats(results, terminalWidth) {
  const statsHeaders = [
    { text: 'Metric', align: 'left' },
    { text: 'Value', align: 'right' }
  ];
  
  const statsRows = [
    [chalk.green('[DIR] Total Files'), (results.totalFiles || 0).toLocaleString()],
    [chalk.blue('[FOL] Directories'), (results.totalDirectories || 0).toLocaleString()],
    [chalk.yellow('[DOC] Total Lines'), (results.totalLines || 0).toLocaleString()],
    [chalk.cyan('[COD] Code Lines'), (results.codeLines || 0).toLocaleString()],
    [chalk.magenta('[COM] Comments'), (results.commentLines || 0).toLocaleString()],
    [chalk.gray('[BLK] Blank Lines'), (results.blankLines || 0).toLocaleString()]
  ];
  
  // Section header
  const sectionHeader = 'SUMMARY STATISTICS';
  const headerPadding = Math.max(0, Math.floor((terminalWidth - sectionHeader.length - 6) / 2));
  console.log(' '.repeat(headerPadding) + chalk.cyan('[STA]') + ' ' + chalk.bold(sectionHeader));
  
  console.log(createResponsiveTable(statsHeaders, statsRows, {
    minColumnWidth: 10,
    padding: 1
  }));
  console.log();
}

/**
 * Displays file type analysis in a consistent format
 */
function displayFileTypeAnalysis(results, terminalWidth, isNarrow) {
  const sectionHeader = 'FILE TYPE ANALYSIS';
  const headerPadding = Math.max(0, Math.floor((terminalWidth - sectionHeader.length - 6) / 2));
  console.log(' '.repeat(headerPadding) + chalk.magenta('[TYP]') + ' ' + chalk.bold(sectionHeader));
  
  const typeHeaders = [
    { text: 'Extension', align: 'left' },
    { text: 'Files', align: 'right' },
    { text: 'Lines', align: 'right' },
    { text: 'Code', align: 'right' },
    { text: 'Comments', align: 'right' },
    { text: 'Blank', align: 'right' }
  ];
  
  // Remove columns for narrow terminals
  if (isNarrow) {
    typeHeaders.splice(4, 2); // Remove Comments and Blank
  }
  
  const typeRows = [];
  const sortedByFiles = Object.entries(results.byFileType)
    .sort((a, b) => b[1].files - a[1].files);
  
  sortedByFiles.forEach(([type, stats]) => {
    const colors = getLanguageColor(type);
    const row = [
      colors(type.toUpperCase()),
      stats.files.toString(),
      stats.totalLines.toLocaleString(),
      stats.codeLines.toLocaleString()
    ];
    
    if (!isNarrow) {
      row.push(stats.commentLines.toLocaleString());
      row.push(stats.blankLines.toLocaleString());
    }
    
    typeRows.push(row);
  });
  
  console.log(createResponsiveTable(typeHeaders, typeRows, {
    minColumnWidth: 6,
    padding: 1
  }));
  console.log();
}

/**
 * Displays language distribution with consistent alignment
 */
function displayLanguageDistribution(results, terminalWidth) {
  const sectionHeader = 'LANGUAGE DISTRIBUTION';
  const headerPadding = Math.max(0, Math.floor((terminalWidth - sectionHeader.length - 6) / 2));
  console.log(' '.repeat(headerPadding) + chalk.yellow('[CHT]') + ' ' + chalk.bold(sectionHeader));
  
  const sortedByLines = Object.entries(results.byFileType)
    .sort((a, b) => b[1].totalLines - a[1].totalLines);
  
  const chartWidth = Math.min(60, terminalWidth - 2);
  const leftColumnWidth = 20; // Fixed width for rank, type, and percentage
  const barWidth = chartWidth - leftColumnWidth - 3; // -3 for borders and spacing
  
  // Draw top border
  console.log(chalk.gray('┌' + '─'.repeat(chartWidth) + '┐'));
  
  sortedByLines.forEach(([type, stats], index) => {
    const percentage = results.totalLines > 0 ? ((stats.totalLines / results.totalLines) * 100).toFixed(1) : '0.0';
    const colors = getLanguageColor(type);
    
    const progressBar = createProgressBar(parseFloat(percentage), barWidth, {
      filledChar: '█',
      emptyChar: '░',
      showPercentage: false
    });
    
    const sparkle = index === 0 ? '*' : index === 1 ? '+' : 'x';
    const typeDisplay = truncateText(type.toUpperCase(), 8);
    
    // Create left column content with fixed width
    const leftContent = `${sparkle} ${colors(typeDisplay)} ${chalk.yellow(percentage + '%')}`;
    const leftPadding = Math.max(0, leftColumnWidth - leftContent.length - 1);
    
    // Build the complete line
    const lineContent = chalk.gray('│') + 
                       ' ' + 
                       leftContent + 
                       ' '.repeat(leftPadding) + 
                       chalk.gray('│') + 
                       ' ' + 
                       progressBar + 
                       ' ' + 
                       chalk.gray('│');
    
    console.log(lineContent);
  });
  
  // Draw bottom border
  console.log(chalk.gray('└' + '─'.repeat(chartWidth) + '┘'));
  console.log();
}

/**
 * Displays largest files ranking in a consistent format
 */
function displayLargestFiles(results, terminalWidth) {
  const sectionHeader = 'LARGEST FILES RANKING';
  const headerPadding = Math.max(0, Math.floor((terminalWidth - sectionHeader.length - 6) / 2));
  console.log(' '.repeat(headerPadding) + chalk.red('[LEN]') + ' ' + chalk.bold(sectionHeader));
  
  const fileHeaders = [
    { text: 'Rank', align: 'center' },
    { text: 'File Name', align: 'left' },
    { text: 'Lines', align: 'right' },
    { text: 'Type', align: 'center' }
  ];
  
  const fileRows = [];
  results.largestFiles.slice(0, 10).forEach((file, index) => {
    const rankIcon = index === 0 ? '1st' : index === 1 ? '2nd' : index === 2 ? '3rd' : `${index + 1}th`;
    const fileName = truncateText(file.path, 35);
    const colors = getLanguageColor(file.type);
    
    fileRows.push([
      rankIcon,
      chalk.cyan(fileName),
      chalk.yellow(file.lines.toString()),
      colors(file.type.toUpperCase())
    ]);
  });
  
  console.log(createResponsiveTable(fileHeaders, fileRows, {
    minColumnWidth: 6,
    padding: 1
  }));
  console.log();
}

/**
 * Displays code quality metrics in a consistent format
 */
function displayCodeQualityMetrics(results, terminalWidth) {
  const sectionHeader = 'CODE QUALITY METRICS';
  const headerPadding = Math.max(0, Math.floor((terminalWidth - sectionHeader.length - 6) / 2));
  console.log(' '.repeat(headerPadding) + chalk.blue('[MET]') + ' ' + chalk.bold(sectionHeader));
  
  const commentRatio = results.totalLines > 0 ? (results.commentLines / results.totalLines * 100).toFixed(1) : '0.0';
  const codeRatio = results.totalLines > 0 ? (results.codeLines / results.totalLines * 100).toFixed(1) : '0.0';
  const avgLinesPerFile = results.totalFiles > 0 ? Math.round(results.totalLines / results.totalFiles) : 0;
  
  const boxWidth = Math.min(50, terminalWidth - 4);
  
  // Comment ratio with quality indicator
  const commentQuality = commentRatio > 20 ? chalk.green('[GOOD]') : 
                         commentRatio > 10 ? chalk.yellow('[FAIR]') : 
                         chalk.red('[POOR]');
  
  // Code ratio with efficiency indicator
  const codeEfficiency = codeRatio > 70 ? chalk.green('[FAST]') : codeRatio > 50 ? chalk.yellow('[NORM]') : chalk.red('[SLOW]');
  
  // Average lines per file with complexity indicator
  const complexity = avgLinesPerFile > 500 ? chalk.red('[HIGH]') : 
                     avgLinesPerFile > 200 ? chalk.yellow('[MED]') : 
                     chalk.green('[LOW]');
  
  console.log(chalk.gray('┌' + '─'.repeat(boxWidth) + '┐'));
  
  // Create aligned metric lines
  const metrics = [
    {
      tag: 'COM',
      label: 'Comment Ratio',
      value: commentRatio + '%',
      indicator: commentQuality
    },
    {
      tag: 'COD',
      label: 'Code Ratio',
      value: codeRatio + '%',
      indicator: codeEfficiency
    },
    {
      tag: 'DOC',
      label: 'Avg Lines/File',
      value: avgLinesPerFile.toString(),
      indicator: complexity
    }
  ];
  
  metrics.forEach(metric => {
    const tagColored = chalk.blue(`[${metric.tag}]`);
    const content = `${tagColored} ${metric.label}: ${metric.value.padStart(5)} ${metric.indicator}`;
    const padding = Math.max(0, boxWidth - content.length - 2); // -2 for borders
    console.log(chalk.gray('│') + content + ' '.repeat(padding) + chalk.gray('│'));
  });
  
  console.log(chalk.gray('└' + '─'.repeat(boxWidth) + '┘'));
  console.log();
}

/**
 * Displays quick analysis results with responsive layout
 * @param {Object} results - Analysis results
 */
function displayQuickResults(results) {
  const terminalWidth = getTerminalWidth();
  
  console.log(chalk.cyan.bold('\n╭ QUICK ANALYSIS ╮\n'));
  console.log(chalk.yellow('╠═' + '═'.repeat(Math.min(46, terminalWidth - 4)) + '═╣\n'));
  
  // Quick stats in a compact format
  const quickStats = [
    { label: 'Files', value: results.totalFiles, tag: 'FIL', color: 'green' },
    { label: 'Total Lines', value: results.totalLines, tag: 'LIN', color: 'yellow' },
    { label: 'Code Lines', value: results.codeLines, tag: 'COD', color: 'cyan' },
    { label: 'Avg Lines/File', value: Math.round(results.totalLines / results.totalFiles), tag: 'AVG', color: 'white' }
  ];
  
  const quickWidth = Math.min(46, terminalWidth - 4);
  
  quickStats.forEach(stat => {
    const prefix = chalk.gray('│') + ' ' + chalk[stat.color](`[${stat.tag}]`);
    const content = ` ${stat.label}:${stat.value.toLocaleString()}`;
    const availableWidth = quickWidth - 7; // -7 for prefix and borders
    const padding = Math.max(0, availableWidth - content.length);
    console.log(prefix + content + ' '.repeat(padding) + chalk.gray('│'));
  });
  
  console.log(chalk.yellow('╚═' + '═'.repeat(quickWidth) + '═╝'));
  console.log();
}

/**
 * Displays file analysis results with responsive layout
 * @param {Object} results - File analysis results
 */
function displayFileResults(results) {
  const terminalWidth = getTerminalWidth();
  
  console.log(chalk.cyan.bold('\n╭ FILE ANALYSIS ╮\n'));
  console.log(chalk.yellow('╠═' + '═'.repeat(Math.min(48, terminalWidth - 4)) + '═╣\n'));
  
  // File info
  const fileInfoWidth = Math.min(48, terminalWidth - 4);
  
  const formatLine = (prefix, label, content, colorFunc = chalk.white) => {
    const tagMatch = prefix.match(/\[(...)\]/);
    const tag = tagMatch ? tagMatch[1] : 'NAM';
    const coloredPrefix = chalk.gray('│') + ' ' + chalk[tag === 'NAM' ? 'cyan' : tag === 'TYP' ? 'white' : 'yellow'](prefix);
    const text = ` ${label}${content}`;
    const availableWidth = fileInfoWidth - 7; // -7 for prefix and borders
    const padding = Math.max(0, availableWidth - text.length);
    return coloredPrefix + text + ' '.repeat(padding) + chalk.gray('│');
  };
  
  console.log(formatLine('[NAM]', 'Name: ', chalk.cyan.bold(truncateText(results.fileName, 30))));
  console.log(formatLine('[TYP]', 'Type: ', chalk.white.bold(Object.keys(results.byFileType)[0].toUpperCase())));
  console.log(formatLine('[SIZ]', 'Size: ', chalk.yellow.bold(formatFileSize(results.fileSize))));
  console.log();
  
  // Line counts
  const lineStats = [
    { label: 'Total Lines', value: results.totalLines, tag: 'TOT', color: 'yellow' },
    { label: 'Code Lines', value: results.codeLines, tag: 'COD', color: 'cyan' },
    { label: 'Comments', value: results.commentLines, tag: 'COM', color: 'magenta' },
    { label: 'Blank Lines', value: results.blankLines, tag: 'BLA', color: 'gray' }
  ];
  
  lineStats.forEach(stat => {
    const prefix = chalk.gray('│') + ' ' + chalk[stat.color](`[${stat.tag}]`);
    const content = ` ${stat.label}:${stat.value.toLocaleString()}`;
    const availableWidth = fileInfoWidth - 7; // -7 for prefix and borders
    const padding = Math.max(0, availableWidth - content.length);
    console.log(prefix + content + ' '.repeat(padding) + chalk.gray('│'));
  });
  
  console.log(chalk.yellow('╚═' + '═'.repeat(Math.min(48, terminalWidth - 4)) + '═╝'));
  console.log();
}

/**
 * Formats file size in human readable format
 * @param {number} bytes - File size in bytes
 * @returns {string} Formatted file size
 */
function formatFileSize(bytes) {
  if (bytes === 0) return '0 B';
  
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

module.exports = {
  displayResults,
  displayQuickResults,
  displayFileResults
};